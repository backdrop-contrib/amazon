<?php
// $Id$

/**
 * @file
 * Defines a field type for referencing an Amazon product.
 */

 /**
 * Implementation of hook_menu().
 */
function asin_menu() {
  $items = array();
  $items['asin/autocomplete'] = array(
    'page callback' => 'asin_autocomplete_callback',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK
  );
  return $items;
}


/**
 * Implementation of hook_field_info().
 */
function asin_field_info() {
  return array(
    'asin' => array(
      'label' => t('Amazon item'),
      'description' => t('Store the id of a product listed on Amazon.com.'),
      'default_widget' => 'asin_text',
      'default_formatter' => 'default',
    ),
  );
}


///**
// * @todo: This is the leftover from D6 hook_field. Seems that there's some
// * views stuff yet to be done?
// */
//function asin_field_settings($op, $field) {
//// TODO: Views data stuff
//      $data = content_views_field_views_data($field);
//      $db_info = content_database_info($field);
//      $table_alias = content_views_tablename($field);
//
//      // Filter: Add a 'many to one' filter.
//      $copy = $data[$table_alias][$field['field_name'] . '_asin'];
//      $copy['title'] = t('@label (!name) - Allowed values', array('@label' => $field['widget']['label'], '!name' => $field['field_name']));
//      $copy['filter']['handler'] = 'views_handler_filter_many_to_one';
//      unset($copy['field'], $copy['argument'], $copy['sort']);
//      $data[$table_alias][$field['field_name'] . '_value_many_to_one'] = $copy;
//      // Argument : swap the handler to the 'many to one' operator.
//      $data[$table_alias][$field['field_name'] . '_value']['argument']['handler'] = 'views_handler_argument_many_to_one';
//
//      // Add a relationship for related node.
//      $data[$table_alias][$field['field_name'] . '_asin']['relationship'] = array(
//        'base' => 'amazon_item',
//        'field' => $db_info['columns']['asin']['column'],
//        'handler' => 'views_handler_relationship',
//      );
//      return $data;
//}


/**
 * Trim spaces from the front/back of each ASIN in an array.
 *
 * @param $items
 *   Array of ASINS
 * @return
 *   Same array of ASINs, trimmed
 */
function _asin_trim_items(&$items) {
  foreach ($items as $delta => &$item) {
    $item = trim($item);
  }
}

/**
 * Get an array of items from Amazon.
 *
 * @param $items
 *   An array of ASIN strings
 * @return
 *   An array of amazon item arrays, keyed by ASIN.
 */
function _asin_load_items(&$items) {
  if (is_string($items)) {
    $items = array($items);
  }
  $asins = array();
  foreach ($items as $delta => &$item) {
    if (!empty($item)) {
      $asin = trim($item);
      $asin = amazon_convert_to_asin($asin);
      $asins[] = $asin;
    }
  }
  return amazon_item_lookup($asins);
}

/**
 * Implements of hook_field_is_empty().
 */
function asin_field_is_empty($item, $field) {
  if (empty($item['asin'])) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implementation of hook_field_formatter_info().
 */
function asin_field_formatter_info() {
  return array(
    'default' => array(
      'label' => t('Thumbnail with title'),
      'field types' => array('asin'),
      'multiple values' => FIELD_BEHAVIOR_DEFAULT,
    ),
    'details' => array(
      'label' => t('Thumbnail with details'),
      'field types' => array('asin'),
      'multiple values' => FIELD_BEHAVIOR_DEFAULT,
    ),
    'thumbnail' => array(
      'label' => t('Thumbnail image'),
      'field types' => array('asin'),
      'multiple values' => FIELD_BEHAVIOR_DEFAULT,
    ),
    'medium' => array(
      'label' => t('Medium image'),
      'field types' => array('asin'),
      'multiple values' => FIELD_BEHAVIOR_DEFAULT,
    ),
    'large' => array(
      'label' => t('Large image'),
      'field types' => array('asin'),
      'multiple values' => FIELD_BEHAVIOR_DEFAULT,
    ),
    'inline' => array(
      'label' => t('Link to item'),
      'field types' => array('asin'),
      'multiple values' => FIELD_BEHAVIOR_DEFAULT,
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function asin_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  foreach ($items as $delta => $item) {
    $asin = trim($item['asin']);
    $asins = array();
    if (!empty($asin)) {
      $asins = amazon_item_lookup("$asin");
      // TODO: kill off amazon_inline_item. There's no reason for it to clutter the earth.
      $theme_function = $display['type'] == 'inline' ? 'amazon_inline_item' : 'amazon_item';
      $element[$delta] = array('#markup' => theme($theme_function, array('item' => $asins["$asin"], 'style' => $display['type'])));
    }
  }
  return $element;
}


/**
 * Implementation of hook_field_widget_info().
 *
 */
function asin_field_widget_info() {
  return array(
    'asin_text' => array(
      'label' => t('Amazon ASIN Text field'),
      'field types' => array('asin'),
    ),
    'asin_autocomplete' => array(
      'label' => t('Product name autocomplete'),
      'field types' => array('asin'),
    ),
  );
}

/**
 * Implements hook_field_widget_form().
 *
 */
function asin_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $base) {
  $element = $base;
  $element['asin'] = $base + array(
    '#type' => 'textfield',
    '#default_value' => !empty($items[$delta]['asin']) ? $items[$delta]['asin'] : '',
  );
  switch ($instance['widget']['type']) {
    case 'asin_text':
      $element['asin']['#size'] = 25;
      $element['asin']['#element_validate'] = array('asin_field_widget_element_validate');
      break;

    case 'asin_autocomplete':
      $element['asin']['#autocomplete_path'] = 'asin/autocomplete';
      $element['asin']['#value_callback'] = 'asin_autocomplete_value';
      $element['asin']['#maxlength'] = 256;
      $element['asin']['#element_validate'][] = 'asin_autocomplete_validate';
      break;
  }

  $form_state['langcode'] = $langcode;
  return $element;
}

/**
 * Widget validation function.
 *
 * Checks to see if we can look up an ASIN, URL, or ISBN-13 using the
 * provided text. If we can, it's OK and we turn it into an ASIN.
 * Otherwise, flag as error.
 */
function asin_field_widget_element_validate($element, &$form_state) {
  $field_name = $element['#field_name'];
  $langcode = $form_state['langcode'];

  foreach ($form_state['values'][$field_name][$langcode] as $delta => &$item) {
    $asin = $item['asin'];
    if (!empty($asin) && is_numeric($delta)) {
      $results = _asin_load_items($asin);
      if (empty($results)) {
        form_set_error("{$field_name}][{$langcode}][{$delta}][asin]", t('No Amazon product with the ASIN "%id" could be located.', array('%id' => $asin)));
      }
      else {
        $item['asin'] = (string)key($results);
      }
    }
  }
}


/**
 * Autocomplete callback for the asin_autocomplete widget.
 */
function asin_autocomplete_callback($string = '') {
  $items = $matches = array();
  // Search Amazon.
  $parameters = array(
    'ResponseGroup' => 'Small',
    'SearchIndex' => 'Blended',
    'Keywords' => urlencode($string)
  );
  $results = amazon_http_request('ItemSearch', $parameters);
  // Process the results.
  foreach($results->Items->Item as $xml) {
    $items[(string) $xml->ASIN] = (string) $xml->ItemAttributes->Title;
  }
  // Create our response.
  foreach ($items as $asin => $title) {
    // Add a class wrapper for a few required CSS overrides.
    $matches[$title . ' [asin:' . $asin . ']'] = '<div class="reference-autocomplete">'. $title . '</div>';
  }
  drupal_json_output($matches);
}

/**
 * Validate the autocomplete widget.
 *
 * This corrects the value (we want just the ASIN, not the whole title).
 */
function asin_autocomplete_validate($element, &$form_state) {
  $value = $element['#value'];
  $asin = NULL;
  if (preg_match('!.*\[asin\:([a-zA-Z0-9]*)\]!', $value, $matches)) {
    $asin = $matches[1];
  }
  else {
    $asin = $value;
  }
  form_set_value($element, $asin, $form_state);
}


/**
 * Implements hook_field_views_data().
 *
 * Through this hook we're given the chance to change the views schema
 * data for the asin field. The primary thing to be done is to add a join
 * on the ASIN type to the amazon_item views base stuff.
 */
function asin_field_views_data($field) {
  // TODO: This should be refactored something like the commented out stuff
  // below, but I don't think I'll work on it right now.
  // There's no reason to repeat all this stuff.
  // This can also be done with hook_field_views_data_alter().

//  $data = field_views_field_default_views_data($field);
//
//  $tables = array_keys($data);
//
//  foreach ($tables as $table) {
//    // Add a relationship for related node.
//    $data[$table][$column_real_name]['relationship'] = array(
//      'base' => 'amazon_item',
//      'field' => $column_real_name,
//      'handler' => 'views_handler_relationship',
//    );
//  }

  $field_types = field_info_field_types();

  // Check the field module is available.
  if (!isset($field_types[$field['type']])) {
    return;
  }

  $data = array();

  $current_table = _field_sql_storage_tablename($field);
  $revision_table = _field_sql_storage_revision_tablename($field);

  // The list of entity:bundle that this field is used in.
  $bundles_names = array();
  $supports_revisions = FALSE;

  // Build the relationships between the field table and the entity tables.
  foreach ($field['bundles'] as $entity => $bundles) {
    $entity_info = entity_get_info($entity);

    $data[$current_table]['table']['join'][$entity_info['base table']] = array(
      'left_field' => $entity_info['entity keys']['id'],
      'field' => 'entity_id',
      'extra' => array(array('field' => 'etid', 'value' => _field_sql_storage_etid($entity), 'numeric' => TRUE)),
    );

    if (!empty($entity_info['entity keys']['revision']) && !empty($entity_info['revision table'])) {
      $data[$revision_table]['table']['join'][$entity_info['revision table']] = array(
        'left_field' => $entity_info['entity keys']['revision'],
        'field' => 'revision_id',
        'extra' => array(array('field' => 'etid', 'value' => _field_sql_storage_etid($entity), 'numeric' => TRUE)),
      );

      $supports_revisions = TRUE;
    }

    foreach ($bundles as $bundle) {
      $bundles_names[] = t('@entity:@bundle', array('@entity' => $entity, '@bundle' => $bundle));
    }
  }

  $tables = array();
  $tables[FIELD_LOAD_CURRENT] = $current_table;
  if ($supports_revisions) {
    $tables[FIELD_LOAD_REVISION] = $revision_table;
  }

  // Add the field handler for this field.
  $title_short = $field['field_name'];
  foreach ($tables as $type => $table) {
    if ($type == FIELD_LOAD_CURRENT) {
      $group = t('Fields');
      $column = 'entity_id';
    }
    else {
      $group = t('Fields (historical data)');
      $column = 'revision_id';
    }

    $data[$table][$column] = array(
      'group' => $group,
      'title' => $title_short,
      'title short' => $title_short,
      'help' =>  t('Appears in: @bundles', array('@bundles' => implode(', ', $bundles_names))),
    );
    $data[$table][$column]['field'] = array(
      'field' => $column,
      'table' => $table,
      'handler' => 'views_handler_field_field',
      'click sortable' => TRUE,
      'field_name' => $field['field_name'],
      'additional fields' => array('etid'),
    );
  }

  foreach ($field['columns'] as $column => $attributes) {
    $sort = !empty($attributes['sortable']) ? TRUE : FALSE;

    // Identify likely filters and arguments for each column based on field type.
    switch ($attributes['type']) {
      case 'int':
      case 'mediumint':
      case 'tinyint':
      case 'bigint':
      case 'serial':
        $filter = 'views_handler_filter_numeric';
        $argument = 'views_handler_argument_numeric';
        break;
      case 'numeric':
      case 'float':
        $filter = 'views_handler_filter_float';
        $argument = 'views_handler_argument_numeric';
        break;

      case 'text':
      case 'blob':
      default:
        $filter = 'views_handler_filter_string';
        $argument = 'views_handler_argument_string';
        break;
    }

    // Note: we don't have a label available here, because we are at the field
    // level, not at the instance level.
    if (count($field['columns']) == 1) {
      $title = t('@label (!name)', array('@label' => $field['field_name'], '!name' => $field['field_name']));
      $title_short = $field['field_name'];
    }
    else {
      $title = t('@label (!name) - !column', array('@label' => $field['field_name'], '!name' => $field['field_name'], '!column' => $column));
      $title_short = t('@label-truncated - !column', array('@label-truncated' => $field['field_name'], '!column' => $column));
    }

    foreach ($tables as $type => $table) {
      $group = $type == FIELD_LOAD_CURRENT ? t('Fields') : t('Fields (historical data)');
      $column_real_name = $field['storage']['details']['sql'][$type][$table][$column];

      // Load all the fields from the table by default.
      $additional_fields = array_values($field['storage']['details']['sql'][$type][$table]);

      $data[$table][$column_real_name] = array(
        'group' => $group,
        'title' => $title,
        'title short' => $title_short,
        'help' =>  t('Appears in: @bundles', array('@bundles' => implode(', ', $bundles_names))),
      );

      $data[$table][$column_real_name]['argument'] = array(
        'field' => $column_real_name,
        'table' => $table,
        'handler' => $argument,
        'additional fields' => $additional_fields,
        'content_field_name' => $field['field_name'],
        'empty field name' => t('<No value>'),
      );
      $data[$table][$column_real_name]['filter'] = array(
        'field' => $column_real_name,
        'table' => $table,
        'handler' => $filter,
        'additional fields' => $additional_fields,
        'content_field_name' => $field['field_name'],
        'allow empty' => TRUE,
      );
      if (!empty($sort)) {
        $data[$table][$column_real_name]['sort'] = array(
          'field' => $column_real_name,
          'table' => $table,
          'handler' => 'content_handler_sort',
          'additional fields' => $additional_fields,
          'content_field_name' => $field['field_name'],
        );
      }

      // Add a relationship for related node.
      $data[$table][$column_real_name]['relationship'] = array(
        'base' => 'amazon_item',
        'field' => $column_real_name,
        'handler' => 'views_handler_relationship',
      );

      // Expose additional delta column for multiple value fields.
      if ($field['cardinality'] > 1 || $field['cardinality'] == FIELD_CARDINALITY_UNLIMITED) {
        $title = t('@label (!name) - delta', array('@label' => $field['field_name'], '!name' => $field['field_name']));
        $title_short = t('!name - delta', array('@name' => $field['field_name']));

        $data[$table]['delta'] = array(
          'group' => $group,
          'title' => $title,
          'title short' => $title_short,
          'help' => t('Delta - Appears in: @bundles', array('@bundles' => implode(', ', $bundles_names))),
        );
        $data[$table]['delta']['argument'] = array(
          'field' => 'delta',
          'table' => $table,
          'handler' => 'views_handler_argument_numeric',
          'additional fields' => $additional_fields,
          'empty field name' => t('<No value>'),
        );
        $data[$table]['delta']['filter'] = array(
          'field' => 'delta',
          'table' => $table,
          'handler' => 'views_handler_filter_numeric',
          'additional fields' => $additional_fields,
          'allow empty' => TRUE,
        );
        $data[$table]['delta']['sort'] = array(
          'field' => 'delta',
          'table' => $table,
          'handler' => 'views_handler_sort',
          'additional fields' => $additional_fields,
        );
        // Add a relationship for related node.
        $data[$table]['delta']['relationship'] = array(
          'base' => 'amazon_item',
          'table' => $table,
          'field' => 'delta',
          'handler' => 'views_handler_relationship',
        );
      }
    }
  }

  return $data;
}



/**
 * Implementation of hook_feeds_node_processor_targets_alter().
 *
 * @see FeedsNodeProcessor::getMappingTargets().
 */
function asin_feeds_node_processor_targets_alter(&$targets, $content_type) {
  $info = content_types($content_type);
  $fields = array();
  if (isset($info['fields']) && count($info['fields'])) {
    foreach ($info['fields'] as $field_name => $field) {
      if ($field['type'] == 'asin') {
        $fields[$field_name] = isset($field['widget']['label']) ? $field['widget']['label'] : $field_name;
      }
    }
  }
  foreach ($fields as $k => $name) {
    $targets[$k] = array(
      'name' => $name,
      'callback' => 'asin_feeds_set_target',
      'description' => t('The CCK !name field of the node.', array('!name' => $name)),
    );
  }
}

/**
 * Callback for mapping. Here is where the actual mapping happens.
 *
 * When the callback is invoked, $target contains the name of the field the
 * user has decided to map to and $value contains the value of the feed item
 * element the user has picked as a source.
 */
function asin_feeds_set_target($node, $target, $value) {

  $field = isset($node->$target) ? $node->$target : array();

  // Handle multiple value fields.
  if (is_array($value)) {
    $i = 0;
    foreach ($value as $v) {
      if (!is_array($v) && !is_object($v)) {
        $field[$i]['asin'] = $v;
      }
      $i++;
    }
  }
  else {
    $field[0]['asin'] = $value;
  }

  $node->$target = $field;
}
