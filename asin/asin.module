<?php
// $Id$

/**
 * @file
 * Defines a field type for referencing Amazon products by ISBN or ASIN.
 */

/**
 * Implementation of hook_field_info().
 *
 * Here we indicate that the content module will use its default
 * handling for the view of this field.
 */
function asin_field_info() {
  return array(
    'asin' => array(
      'label' => 'Amazon product',
      'description' => t('Store the Amazon ID of a product in the database.'),
      'callbacks' => array(
        'tables' => CONTENT_CALLBACK_NONE,
      ),
      'multiple values' => CONTENT_HANDLE_CORE,
    ),
  );
}

/**
 * Implementation of hook_field().
 *
 * Validates ASIN fields against Amazon's product database, and handles
 * assorted nodeapi operations for CCK. Funny, this is almost exactly
 * what nodeapi does.
 *
 * If we could make fields cross-populate each other, and cross-validate
 * each other, man... we could totally eliminate hook_nodeapi altogether.
 * Wouldn't that be amazing? Wouldn't it be cool? I know I get happy just
 * thinking about it.
 */
function asin_field($op, &$node, $field, &$items, $teaser, $page) {
  $fieldname = $field['field_name'];

  switch ($op) {
    case 'validate':
      $results = _asin_lookup_values($items);
      $seen_asins = array();
      foreach ($items as $delta => $asin) {
        $error_field = $field['field_name'] .']['. $delta .'][asin';
        if (!empty($item['asin'])) {
          // Oh, man oh man will these functions get horked up if you change the
          // deltas around and entry the same ASIN multiple times. We're just
          // going to kick back an error if someone tries that.
          if (!empty($seen_asins[$item['asin']])) {
            form_set_error($error_field, t('%name : The Amazon product ID %id may only be added to a field once.', array('%name' => t($field['widget']['label']), '%id' => $item['asin'])));
          }

          // Also make sure the ASIN actually exists.
          if (empty($results[$item['asin']])) {
            form_set_error($error_field, t('%name : No Amazon product with the ID %id could be located.', array('%name' => t($field['widget']['label']), '%id' => $item['asin'])));
          }
          $seen_asin[$item['asin']] = TRUE;
        }
      }
      return $items;

    case 'load':
      // Holy smokes, this is expensive. Thanks for caching things, CCK!
      $sql = "SELECT * FROM {amazon_item_node} WHERE vid = %d AND module = '%s'";
      $results = db_query($sql, $node->vid, 'asin_'. $fieldname);
      $items = array();
      $lookup_list = array();
      while ($item = db_fetch_array($results)) {
        $items[$item['delta']] = $item['asin'];
      }

      $details = amazon_item_lookup($items);
      foreach ($items as $delta => $item) {
        $items[$delta] = $details[$item];
      }

      return array($fieldname => $items);

    case 'insert':
    case 'update':
      // Check to see whether we should make a new revision. If so insert, if not
      // update the existing one based on vid.
      $asins = array();
      foreach ($items as $delta => $item) {
        if (!empty($item)) {
          $items[$delta]['nid'] = $node->nid;
          $items[$delta]['vid'] = $node->vid;
          $items[$delta]['module'] = 'asin_'. $fieldname;
          $items[$delta]['delta'] = $delta;
        }
      }

      if ($node->revision == FALSE && $op == 'update') {
        // We also have to remove any items that were previously associated
        // with the item.
        $sql = "DELETE FROM {amazon_item_node} WHERE vid = %d AND module = '%s'";

        // Tag these onto the end. It's horrific but it works.
        db_query($sql, $node->vid, 'asin_'. $fieldname);
      }

      foreach($items as $item) {
        drupal_write_record('amazon_item_node', $item);
      }

      break;

    case 'delete':
      $sql = "DELETE FROM {amazon_item_node} WHERE nid = %d AND module = '%s'";
      db_query($sql, $node->nid, 'asin_'. $fieldname);
      break;

    case 'delete revision':
      $sql = "DELETE FROM {amazon_item_node} WHERE vid = %d AND module = '%s'";
      db_query($sql, $node->vid, 'asin_'. $fieldname);
      break;

    case 'sanitize':
      // Er. What should I do here? Help!
      break;
  }
}

function _asin_lookup_values($items) {
  $asins = array();
  foreach($items as $item) {
    $asins[] = $item['asin'];
  }
  return amazon_item_lookup($asins);
}

/**
 * Implementation of hook_content_is_empty().
 */
function asin_content_is_empty($item, $field) {
  if (empty($item['asin'])) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implementation of hook_widget_info().
 *
 * Here we indicate that the content module will handle
 * the default value and multiple values for these widgets.
 *
 * Callbacks can be omitted if default handing is used.
 * They're included here just so this module can be used
 * as an example for custom modules that might do things
 * differently.
 *
 * IMPORTANT! - field and widget names will be truncated to 32 characters in
 * the database and in internal arrays, like content_fields().
 */
function asin_widget_info() {
  return array(
    'asin_textfield' => array(
      'label' => 'Product ID field',
      'field types' => array('asin'),
      'multiple values' => CONTENT_HANDLE_CORE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
       ),
    ),
  );
}

/**
 * Implementation of hook_widget().
 *
 * Attach a single form element to the form. It will be built out and
 * validated in the callback(s) listed in hook_elements. We build it
 * out in the callbacks rather than here in hook_widget so it can be
 * plugged into any module that can provide it with valid
 * $field information.
 *
 * Content module will set the weight, field name and delta values
 * for each form element. This is a change from earlier CCK versions
 * where the widget managed its own multiple values.
 *
 * If there are multiple values for this field, the content module will
 * call this function as many times as needed.
 *
 * @param $form
 *   the entire form array, $form['#node'] holds node information
 * @param $form_state
 *   the form_state, $form_state['values'][$field['field_name']]
 *   holds the field's form values.
 * @param $field
 *   the field array
 * @param $items
 *   array of default values for this field
 * @param $delta
 *   the order of this item in the array of subelements (0, 1, 2, etc)
 *
 * @return
 *   the form item for a single element for this field
 */
function asin_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  $element['asin'] = array(
    '#title' => t($field['widget']['label']),
    '#type' => 'textfield',
    '#default_value' => isset($items[$delta]['asin']) ? $items[$delta]['asin'] : '',
    '#description' => t($field['widget']['description']),
  );
  if (isset($items[$delta]) && $data = amazon_item_lookup($items[$delta]['asin'])) {
    $element['preview']['#value'] = '<div class="product-hint">'. theme('amazon_item', $data[$items[$delta]['asin']], 'inline') .'</div>';
  }
  return $element;
}


/**
 * Implementation of hook_field_formatter_info().
 */
function asin_field_formatter_info() {
  return array(
    'default' => array(
      'label' => 'Default',
      'field types' => array('asin'),
      'multiple values' => CONTENT_HANDLE_CORE,
    ),
  );
}

function asin_theme() {
  return array(
    'asin_formatter_default' => array(
      'arguments' => array('element' => NULL),
      'function' => 'theme_asin_formatter_generic'
    ),
  );
}

function theme_asin_formatter_generic($element) {
  return theme('amazon_item', $element['#item'], $element['#formatter']);
}
